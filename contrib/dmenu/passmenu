#!/usr/bin/env bash

##
## A dynamic pass entry multi selection menu.
##
##
##

## DEPENDENCIES;  pass, dmenu
## (optional)	  libnotify, xdotool

shopt -s nullglob globstar failglob
set -euo pipefail

## SETTINGS
X_SELECTION=${PASSWORD_STORE_X_SELECTION:-clipboard}
CLIP_TIME=${PASSWORD_STORE_CLIP_TIME:-45}
prefix=${PASSWORD_STORE_DIR:-$HOME/.password-store}
version=passmenu-0.2.8

arg1=${1:-}
arg2=${2:-}
password_files=( "$prefix"/**/*.gpg )
password_files=( "${password_files[@]#$prefix/}" )
password_files=( "${password_files[@]%.gpg}" )
cleanup=False
selection=''
before=''
myname=${0##*/}
userID=$(id -u "$(whoami)")
usage="$myname [-h help] [-k kill] [-v version] [-c clip] [-q quiet] [-- dmenu]"


## Try libnotify first.
{ hash notify-send &>/dev/null && notifyit=0; } ||
{ printf '%s\n' "w: libnotify not found" && notifyit=1; }

_notify () {
  message=$1
  [[ $notifyit == 1 ]] && 
  notify-send "$message" --icon=dialog-information
  printf '%s\n' "$message"
}

_clear () {
  ## Removes old filelock(s).
  umask 077
  stalelock=${stalelock:-''}
  stalelock=$(find /tmp -maxdepth 1 -name "$myname.$userID.*" -user "$(whoami)" -print -quit -type d) &&
  if [[ -n "$stalelock" ]]; then
    stalename=${stalelock%.*}
    report=$(pgrep -fa "$myname" | grep bash | sed 's/\s.*$//')
    stalePID=$(printf '%s' "$stalename" | sed -e "s/\/tmp\/$myname\.[0-9]\{1,6\}\?\..*\.//g")
    parentID=$(ps -o pid= --ppid "$stalePID" )
    if [[ $report == *"$stalePID"* ]]; then
      kill "$parentID" &>/dev/null || exit 1
    else
      rmdir /tmp/passmenu."$userID".* &>/dev/null ||
      { _notify "e: Unable to clear old filelock"; exit 1; }
    fi
  fi
}

_finish () {
  [[ $cleanup == True ]] &&
  printf '%s' "$before" | base64 -d | xclip -sel "$X_SELECTION" -i &>/dev/null &&
  compgen -G /tmp/passmenu."$userID"* &>/dev/null &&
  rmdir /tmp/passmenu.*.*."$$".lock &>/dev/null
  exit
}


hash xclip &>/dev/null || { _notify "e: xclip not found. Please install xclip."; exit; }
{ hash xdotool &>/dev/null && typeit=1; } || { _notify "w: xdotool not found."; typeit=0; }
## Check for a qupzilla bug which triggers unwanted x-selection events.
pgrep -fa 'qupzilla' &>/dev/null && _notify "w: conflicts with qupzilla"


[[ $arg1 == *v* || $arg2 == *v* ]] && { _notify "$version" && exit; }
[[ $arg1 == *h* || $arg2 == *h* ]] && { printf '%s\n' "$usage" && exit; }
[[ $arg1 == '--type' || $arg2 == '--type' ]] && { typeit=1 && shift; }
[[ $arg1 == '--notify' || $arg2 == '--notify' ]] && { notifyit=1 && shift; }
[[ ! -e "$prefix" ]] && { _notify "e: $prefix not found." && exit; }

## Runs the _finish funtion on exit.
trap _finish EXIT

## dmenu exits on KeyPress not KeyRelease.
## It might be nice to send KeyRelease event to dummy window.
for selection in $(printf '%s\n' "${password_files[@]}" | dmenu -f "$@"); do
  passel+=("$selection")
done

# Runs the _finish funtion on exit. 
trap _finish EXIT

[[ -n $selection ]] || exit

## Clearing old filelock(s). 
umask 077
stalelock=${stalelock:-''}
stalelock=$(find '/tmp' -maxdepth 1 -name "passmenu.$userID.*" -user "$(whoami)" -print0  -quit -type d) &&
if [[ -n "$stalelock" ]];then
  stalename=${stalelock%.*}
  report=$(ps -u "$(id -u "$(whoami)")" aux | grep "bash" | grep "passmenu" | grep -v "$$")
  # report=$(ps -u "user id") aux | grep "bash" | grep "passmenu" | grep "not itself id")
  report2=$(pgrep -f "${0##*/}" &>/dev/null)
  echo "report2= $report2"
  stalePID=$(printf %s "$stalename" | 
  sed -e "s/\/tmp\/passmenu\.[0-9]\{1,6\}\?\..*\.//g")
  if [[ $report == *"$stalePID"* ]]; then
    kill "$(ps -o pid= --ppid "$stalePID" )" || exit 1
  else
    rmdir /tmp/passmenu."$userID".* &>/dev/null ||
    { _notify ":: Unable to clear old filelock"; exit 1; }
  fi
fi

## Add new filelock
( mktemp -d "/tmp/passmenu.$userID.XXXXXXXXXX.$$.lock" &>/dev/null ||
{ _notify "e: Unable to make filelock."; exit 1; } )

## It would be nice to first test if X-selection is null.
before=$(xclip -sel "$X_SELECTION" -o | base64) || true
cleanup=True
round=0

if [[ $typeit -eq 0 ]]; then
  ## CLIPBOARD
  if [[ ${#passel[@]} -gt "1" ]]; then
    for entry in "${passel[@]}"; do
      pass show "$entry" | sed '1!d' | tr -d '\n' |
      xclip -l 1 -quiet -sel "$X_SELECTION" &>/dev/null
      _notify "${passel[$round]} sent via $X_SELECTION"
      round=$((round + 1))
    done
  else
    pass show "$selection" | sed '1!d' | tr -d '\n' |
    xclip -sel "$X_SELECTION" -i
    _notify "$selection sent via $X_SELECTION"
    sleep "$CLIP_TIME"
  fi
else
  ## AUTOTYPE
  if [[ ${#passel[@]} -gt "1" ]]; then
    for entry in "${passel[@]}"; do
      printf '' | xclip -l 1 -quiet -sel "$X_SELECTION" &>/dev/null
      pass show "$entry" | sed '1!d' | tr -d '\n' | 
      xdotool type --delay --clearmodifiers --file -
      _notify "${passel[$round]} sent via xdotool"
      round=$((round + 1))
    done
  else
    pass show "$selection" | sed '1!d' | tr -d '\n' |
    xdotool type --delay --clearmodifiers --file -
    _notify "selection sent via autotype"
  fi
fi
exit
