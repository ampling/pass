#!/usr/bin/env bash

## DEPENDENCIES;  pass, dmenu
## (optional)     libnotify, xdotool

shopt -s nullglob globstar failglob
set -euo pipefail

## SETTINGS
X_SELECTION=${PASSWORD_STORE_X_SELECTION:-clipboard}
prefix=${PASSWORD_STORE_DIR:-$HOME/.password-store}
version=passmenu-0.1.1

arg1=${1:-} 
arg2=${2:-} 
password_files=( "$prefix"/**/*.gpg )
password_files=( "${password_files[@]#"$prefix"/}" )
password_files=( "${password_files[@]%.gpg}" )
password=''
cleanup=''
before=''
myname=${0##*/}
userID=$(id -u "$(whoami)")
usage="$myname [-h help] [-v version] [<dmenu []>]"


## LIBNOTIFY ROCKS
{ hash notify-send 2>/dev/null && notifyit=1; } || 
{ printf '%s\n' "w: libnotify not found" && notifyit=0; }


_notify () {
  message=$1
  [[ "$notifyit" == 1 ]] && 
  notify-send "$message" --icon=dialog-information || printf '%s\n' "$message"
}


_finish () {
  [[ True == "$cleanup" ]] &&
  printf %s "$before" | base64 -d | xclip -sel "$X_SELECTION" -i &&
  if compgen -G "/tmp/passmenu.$userID*" >/dev/null 2>&1 ;then
    rmdir /tmp/passmenu.*.*."$$".lock >/dev/null 2>&1
  fi
  exit
}



{ hash xdotool 2>/dev/null && clipit=0; } || { _notify "w: xdotool not found."; clipit=0; } 

[[ $arg1 == *v* || $arg2 == *v* ]] && { _notify "$version" && exit; }
[[ $arg1 == *h* || $arg2 == *h* ]] && { printf '%s\n' "$usage" && exit; }
[[ $arg1 == '--clip' || $arg2 == '--clip' ]] && { clipit=1 && shift; }
[[ $arg1 == '--notify' || $arg2 == '--notify' ]] && { notifyit=1 && shift; }
[[ ! -e "$prefix" ]] && { _notify "e: $prefix not found." && exit; }

echo "clipit = $clipit"

## dmenu exits on KeyPress not KeyRelease.
## It might be nice to send KeyRelease event to some dummy window.
for password in $(printf '%s\n' "${password_files[@]}" | dmenu -f "$@"); do
  passel+=("$password")
done

# Runs the _finish funtion on exit. 
trap _finish EXIT

[[ -n $password ]] || exit

## Clearing old filelock(s). 
umask 077
stalelock=${stalelock:-''}
stalelock=$(find '/tmp' -maxdepth 1 -name "$myname.$userID.*" -user "$(whoami)" -print0  -quit -type d) &&
if [[ -n "$stalelock" ]]; then
  stalename=${stalelock%.*}
  report=$(pgrep -fa "$myname" | grep bash | sed 's/\s.*$//')
  stalePID=$(printf %s "$stalename" | 
  sed -e "s/\/tmp\/"$myname"\.[0-9]\{1,6\}\?\..*\.//g")
  if [[ $report == *"$stalePID"* ]]; then
    kill "$(ps -o pid= --ppid "$stalePID" )" || exit 1
  else
    rmdir /tmp/"$myname"."$userID".* >/dev/null 2>&1 ||
    { _notify ":: Unable to clear old filelock"; exit 1; }
  fi
fi

## Adding a new filelock
( mktemp -d "/tmp/passmenu.$userID.XXXXXXXXXX.$$.lock" >/dev/null 2>&1 ||
  { _notify ":: Unable to make filelock."; exit 1; } ) &&
  cleanup=True

# It would be nice to first test if string exists.
before=$(xclip -sel "$X_SELECTION" -o 2>/dev/null | base64) || true
cleanup=True

round=0
if [[ $clipit -eq 0 ]]; then
  for entry in "${passel[@]}"; do
    printf '' | xclip -l 1 -quiet -sel "$X_SELECTION" >/dev/null 2>&1
    { ## AUTOTYPE
    pass show "$entry" | sed '1!d' | tr -d '\n' | 
    xdotool type --delay --clearmodifiers --file -
    } &&
    _notify "${passel[$round]} sent via xdotool"
    round=$((round + 1))
  done
else
  for entry in "${passel[@]}"; do
    { ## CLIPBOARD
    pass show "$entry" | sed '1!d' | tr -d '\n' |
    xclip -l 1 -quiet -sel "$X_SELECTION" >/dev/null 2>&1
    } &&
    _notify "${passel[$round]} sent via $X_SELECTION"
    round=$((round + 1))
  done
fi
exit
